---
layout: default
title: "Menu Prototyping"
---

<div>
  <p>
    This is a prototype for a settings menu that changes the Olli description text.
    You can use checkboxes to choose which pieces of text are included and change the verbosity (length)
    of the included text. You can also reorder the pieces of text by using command-up and command-down.
    To switch between the menu and the Olli description, use accesskeys m (w, s, and v for submenus) and d.
  </p>

  <fieldset id="menu" tabindex="0" accesskey="m">
    <legend>Settings Menu</legend>

    <fieldset class="options-set" id="wayfinding" tabindex="0" accesskey="w">
      <legend>Wayfinding (w)</legend>
      <div> <input type="checkbox" id="viewNumber"> <label for="viewNumber">View Number ("1 of 5")</label> </div>
      <div> <input type="checkbox" id="viewName"> <label for="viewName">View Name ("Apple", "Microsoft")</label> </div>
      <div> <input type="checkbox" id="axisLocation"> <label for="axisLocation">Axis Cell Number ("Grid cell 1 of 5")</label> </div>
    </fieldset>

    <fieldset class="options-set" id="summarizing" tabindex="0" accesskey="s">
      <legend>Summarizing (s)</legend>
      <div> <input type="checkbox" id="min"> <label for="min">Minimum</label> </div>
      <div> <input type="checkbox" id="max"> <label for="max">Maximum</label> </div>
      <div> <input type="checkbox" id="avg"> <label for="avg">Average</label> </div>
      <!-- <div> <input type="checkbox" id="trend"> <label for="trend">Trend</label> </div>
      <div> 
        <input type="checkbox" id="relativeValue" onclick="changeAssociatedInputState(this)"> <label for="relativeValue">Relative Value</label> 
        <input type="number" min='1' max='10' id="relativeValue-input" disabled> <label for="relativeValue-input">Buckets</label>
      </div> -->
    </fieldset>

    <fieldset class="options-set" id="verbosity" tabindex="0" accesskey="v">
      <legend>Verbosity (least to most) (v)</legend>
      <div> 
        <input type="radio" id="v1" name="verbosity" value="1">
        <label for="v1">1</label><br>
      </div>
      <div>
        <input type="radio" id="v2" name="verbosity" value="2">
        <label for="v2">2</label><br>
      </div>
      <div>
        <input type="radio" id="v3" name="verbosity" value="3" checked>
        <label for="v3">3</label><br>
      </div>
    </fieldset>

    <p>
      Switch to preset:
      <select id="switch-preset">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
      <button onclick="loadPreset()">Go</button>
    </p>
    <p>
      Save to preset:
      <select id="save-preset">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
      <button onclick="savePreset()">Save</button>
    </p>
  </fieldset>

  <img src="img/multiSeriesLineChart.JPG">

  <ul id="description"></ul>

  <p>((aria-live speaking hack))</p>
  <div id="speak" aria-live="assertive"></div>
</div>

<style>
  input[type='number']{
    width: 3em;
  } 
  
  .options-set {
    margin: 1em;
  }

  .no-list-style {
    list-style: none;
  }
</style>

<script>
  const TOKEN_TYPES = [
    'viewNumber', 
    'viewName', 
    'axisLocation', 
    'relativeValue', 
    'min', 
    'max', 
    'avg', 
    // 'trend',
  ];

  /***
   *  Event listeners for the menu
   ***/
  let lastActiveDescriptionId = "0"; // 0 is id of root node

  // Reordering event listener
  document.addEventListener('keydown', (e) => {
    if (e.metaKey && e.key === 'ArrowUp') {
      const thisCheckbox = document.activeElement;
      const thisDiv = thisCheckbox.parentNode;
      const previousDiv = thisDiv.previousElementSibling;
      if (previousDiv != null && previousDiv.nodeName !== "LEGEND") {
        // Change menu ordering
        // Note: don't want to call insertBefore(thisDiv, previousDiv)
        // because first parameter to insertBefore loses focus
        thisDiv.insertAdjacentElement('afterend', previousDiv);
        thisCheckbox.focus();
        thisCheckbox.setAttribute('aria-active', true);

        // Change token ordering and refresh description
        thisIdx = TOKEN_TYPES.indexOf(thisCheckbox.id);
        [TOKEN_TYPES[thisIdx], TOKEN_TYPES[thisIdx - 1]] = [TOKEN_TYPES[thisIdx - 1], TOKEN_TYPES[thisIdx]];
        displayRootDescription();   
        speakLastFocused();
      }
    } else if (e.metaKey && e.key === 'ArrowDown') {
      const thisCheckbox = document.activeElement;
      const thisDiv = thisCheckbox.parentNode;
      const nextDiv = thisDiv.nextElementSibling;
      if (nextDiv != null) {
        thisDiv.parentNode.insertBefore(nextDiv, thisDiv);

        thisIdx = TOKEN_TYPES.indexOf(thisCheckbox.id);
        [TOKEN_TYPES[thisIdx], TOKEN_TYPES[thisIdx + 1]] = [TOKEN_TYPES[thisIdx + 1], TOKEN_TYPES[thisIdx]];
        displayRootDescription(); 
        speakLastFocused();  
      }
    }
  })

  function changeAssociatedInputState(input) {
    document.getElementById(`${input.id}-input`).disabled = !input.checked;
  }

  const optionSets = document.getElementsByClassName("options-set");
  for (optionSet of optionSets) {
    for (option of optionSet.children) {
      option.setAttribute('onchange', 'displayRootDescription(); speakLastFocused();');
    }
  }

  function speakLastFocused() {
    srSpeak(document.getElementById(lastActiveDescriptionId).firstChild.innerText);
  }

  /***
   *  Data for the description 
   ***/

  const tree = {
    type: "root",
    tokens: ["A faceted chart with 5 views."],
    children: [
      {
        type: "chart",
        tokens: {
          viewNumber: '1 of 5.',
          name: ['MSFT line chart: "date", "price".', 'MSFT line chart: "date", "price".', 
            'A line chart titled "MSFT" with axes "date" and "price".']
        },
        children: [
          {
            type: 'xAxis',
            tokens: {
              name: 'X-axis titled "date"', 
              span: [', "Jan 1, 2000" to "Jan 1, 2010.".', ' with values from "Jan 1, 2000" to "Jan 1, 2010".',
                ' for a temporal scale with values from "Jan 1, 2000" to "Jan 1, 2010".'],
              viewName: '"MSFT".'
            },
            children: []
          },
          {
            type: 'yAxis',
            tokens: {
              name: 'Y-axis titled "price"',
              span: [', "0" to "800".', 'with values from "0" to "800".',
                ' for a quantitative scale with values from "0" to "800".'],
              avg: ['avg 25', 'Average is 25.', 'The average value is 25.'],
              min: ['min 17.65,', 'Minimum is 17.65.', 'The minimum value is 17.65.'],
              max: ['max 39.81,', 'Maximum is 39.81.', 'The maximum value is 39.81.'],
              // trend: 'The trend is flat.',
              viewName: '"MSFT".'
            },
            children: []
          }
        ]
      },
      {
        type: 'chart',
        tokens: {
          viewNumber: '2 of 5.',
          name: ['AMZN line chart: "date", "price".', 'AMZN line chart: "date", "price".', 
          'A line chart titled "AMZN" with axes "date" and "price".']
        },
        children: [
          {
            type: 'xAxis',
            tokens: {
              viewNumber: '2 of 5.',
              name: 'X-axis titled "date"', 
              span: [', "Jan 1, 2000" to "Jan 1, 2010".', ' with values from "Jan 1, 2000" to "Jan 1, 2010".',
                ' for a temporal scale with values from "Jan 1, 2000" to "Jan 1, 2010".'],
              viewName: '"AMZN".'
            },
            children: [
              {
                type: 'section',
                tokens: {
                  viewNumber: '2 of 5.',
                  span: 'Dec 31, 1997 to Jan 1, 2000.', 
                  values: '0 values.',
                  viewName: '"AMZN".',
                  axisLocation: 'Grid cell 1 of 6.'
                },
                children: []
              },
              {
                type: 'section',
                tokens: {
                  viewNumber: '2 of 5.',
                  span: 'Jan 1, 2000 to Jan 1, 2002.', 
                  values: '24 values.',
                  viewName: '"AMZN".',
                  axisLocation: 'Grid cell 2 of 6.'
                },
                children: [
                  {
                    type: 'datapoint',
                    tokens: {
                      viewNumber: '2 of 5.',
                      value1: '64.56',
                      value2: '946702800000',
                      viewName: '"AMZN".',
                      relativeValue: '1',
                    },
                    children: []
                  },
                  {
                    type: 'datapoint',
                    tokens: {
                      viewNumber: '2 of 5.',
                      value1: '68.87',
                      value2: '949381200000',
                      viewName: '"AMZN".',
                      relativeValue: '1',
                    },
                    children: []
                  },
                ]
              },
            ]
          },
          {
            type: 'yAxis',
            tokens: {
              viewNumber: '2 of 5.',
              name: 'Y-axis titled "price"',
              span: [', "0" to "800".', 'with values from "0" to "800".',
                ' for a quantitative scale with values from "0" to "800".'],
              avg: ['avg 48', 'Average is 48.', 'The average value is 48.'],
              min: ['min 5.97,', 'Minimum is 5.97.', 'The minimum value is 5.97.'],
              max: ['max 135.91,', 'Maximum is 135.91.', 'The maximum value is 135.91.'],
              // trend: 'The trend is flat.',
              viewName: '"AMZN".'
            },
            children: []
          }
        ]
      }
    ]
  }

  displayRootDescription();

  function displayRootDescription() {
    const desc = document.getElementById('description');
    desc.innerHTML = '';
    displayRecursiveDescription(tree, desc);
  }

  // `tree` is the tree to generate a description for
  // `dom` is where to add that description
  // `id` is so you can track back from DOM to tree
  // `flags` are any description tokens to turn on
  function displayRecursiveDescription(tree, dom, id = '0', flags=[]) {
    const root = document.createElement('li');
    root.setAttribute('tabindex', 0);
    root.setAttribute('id', id);
    root.classList.add('no-list-style');
    // TODO this accesskeyt thing is tricky because our onchange restriction is actually complex
    root.setAttribute('onfocus', 'lastActiveDescriptionId = this.id; setDescriptionAccesskey(this);');

    text = document.createElement('span');
    text.innerText = getIndivDescription(tree, flags);
    root.appendChild(text);

    if (tree.children.length > 0) {
      const container = document.createElement('ul');
      for (childIdx in tree.children) {
        displayRecursiveDescription(tree.children[childIdx], container, id + '-' + childIdx);
      }
      root.appendChild(container);
    }
    dom.appendChild(root);
  }

  function getIndivDescription(node, flags) {
    const verbosity = parseInt(document.querySelector('input[name="verbosity"]:checked').value);
    let text = '';

    for (token of Object.keys(node.tokens).sort(tokenSort)) {
      const checkbox = document.getElementById(token);
      let tokenText = node.tokens[token];
      if (Array.isArray(tokenText)) { 
        tokenText = tokenText[verbosity - 1];  // one-indexed
      }

      if (checkbox == null || flags.includes(token)) { 
        // if no setting or flag on, always included
        text += tokenText + ' ';
      } else if (checkbox.checked) { 
        // if setting exists, only add if checked
        text += tokenText + ' ';
      }
    }

    return text;
  }

  // Put all unlisted tokens first, then order remaining tokens by their order in TOKEN_TYPES
  function tokenSort(token1, token2) {
    includes1 = TOKEN_TYPES.includes(token1);
    includes2 = TOKEN_TYPES.includes(token2);

    if (!includes1 && !includes2) {
      return 0;
    } else if (!includes1) {
      return -1;
    } else if (!includes2) {
      return 1;
    }
    return TOKEN_TYPES.indexOf(token1) - TOKEN_TYPES.indexOf(token2);
  }

  function getTreeNode(id) {
    const idxs = id.split('-');
    let node = tree;
    for (idx of idxs.slice(1)) {
      node = node.children[idx];
    }
    return node;
  }

  // Set a particular part of the description to have an accesskey
  function setDescriptionAccesskey(elt) {
    document.querySelectorAll('[accesskey="d"]').forEach(el => el.removeAttribute('accesskey'));
    elt.setAttribute('accesskey', 'd');
  }

  /***
   *  Event listeners for the description
   ***/
  document.onkeydown = function (e) {
    keyboardCommands(e);
    keyboardNavigation(e);
  };

  let keylog = '';
  const tokenNames = ['avg', 'min', 'max', 'trend'];
  function keyboardCommands(e) {
    let keypressed = e.key;
    keylog += keypressed;
    for (tokenName of tokenNames) {
      if (keylog.slice(keylog.length - tokenName.length) === tokenName) {
        const node = getTreeNode(document.activeElement.id);
        document.activeElement.firstChild.innerText = getIndivDescription(node, [tokenName]);
        srSpeak(document.activeElement.firstChild.innerText);
      }
    }
  }

  function keyboardNavigation(e) {
    switch (event.key) {
      case 'ArrowRight':
        setFocusToNextItem(document.activeElement);
        break;
      case 'ArrowLeft':
        setFocusToPreviousItem(document.activeElement);
        break;
      case 'ArrowUp':
        setFocusToParentItem(document.activeElement);
        break;
      case 'ArrowDown':
        setFocusToNextLayer(document.activeElement);
        break;
    }
  }

  function changeFocus(old, nw) {
    nw.tabIndex = 0;
    nw.focus();
    nw.setAttribute('aria-selected', 'true');

    old.tabIndex = -1;
    old.setAttribute('aria-selected', 'false');
  }

  function setFocusToNextItem(currentItem) {
    const id = currentItem.id;
    const parentId = id.slice(0, -2);
    const nextChildId = id.slice(0, -1) + (parseInt(id.slice(-1)) + 1).toString() // add 1 to last num
    if (document.getElementById(parentId) && document.getElementById(nextChildId)) {
      changeFocus(currentItem, document.getElementById(nextChildId));
    }
  }

  function setFocusToPreviousItem(currentItem) {
    const id = currentItem.id;
    const parentId = id.slice(0, -2);
    const prevChildId = id.slice(0, -1) + (parseInt(id.slice(-1)) - 1).toString() // add 1 to last num
    if (document.getElementById(parentId) && document.getElementById(prevChildId)) {
      changeFocus(currentItem, document.getElementById(prevChildId));
    }
  }

  function setFocusToNextLayer(currentItem) {
    const child = document.getElementById(currentItem.id + '-0');
    if (child) {
      changeFocus(currentItem, child);
    }
  }

  function setFocusToParentItem(currentItem) {
    const parent = document.getElementById(currentItem.id.slice(0, -2));
    if (parent) {
      changeFocus(currentItem, parent);
    }
  }


  /***
   *  Presets
   ***/
  
  function fieldsToPreset() {
    const result = {}
    for (optionsSet of document.getElementsByClassName('options-set')) {
      const options = {};
      for (option of optionsSet.children) {
        const value = option.firstElementChild;
        if (value) { // Skips the text/legend nodes
          options[value.id] = value.checked;
        }
      }
      result[optionsSet.id] = options;
    }
    return result;
  }

  const presets = {1: fieldsToPreset(), 2: fieldsToPreset(), 3: fieldsToPreset()}

  function presetToFields(num) {
    const preset = presets[num];
    for (optionsSet of document.getElementsByClassName('options-set')) {
      for (option of optionsSet.children) {
        const value = option.firstElementChild;
        if (value) {
          value.checked = preset[optionsSet.id][value.id];
        }
      }
    }
  }

  function loadPreset() {
    presetToFields(document.getElementById('switch-preset').value);
  }

  function savePreset() {
    presets[document.getElementById('save-preset').value] = fieldsToPreset();
  }

  /***
   *  Hack to make screenreader re-read text when it is changed
   ***/
  function srSpeak(text) {
    console.log(text);
    window.setTimeout(function () {
      const el = document.getElementById('speak');
      el.innerHTML = text;
    }, 100);
  }
</script>