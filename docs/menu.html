---
layout: default
title: "Menu Prototyping"
---

<div>
  <p>
    This is a prototype for a settings menu that changes the Olli description text.
    You can use checkboxes to choose which pieces of text are included and change the verbosity (length)
    of the included text. You can also reorder the pieces of text by using command-up and command-down.
    To switch between the menu and the Olli description, use accesskeys m (w, s, and v for submenus) and d.
  </p>

  <fieldset id="menu" tabindex="0" accesskey="m">
    <legend>Settings Menu</legend>

    <!-- <div>
      <label for=""
    </div> -->

    <!-- <fieldset class="options-set" id="wayfinding" tabindex="0" accesskey="w">
      <legend>Wayfinding (w)</legend>
      <div> <input type="checkbox" id="viewNumber"> <label for="viewNumber">View Number ("1 of 5")</label> </div>
      <div> <input type="checkbox" id="viewName"> <label for="viewName">View Name ("Apple", "Microsoft")</label> </div>
      <div> <input type="checkbox" id="axisLocation"> <label for="axisLocation">Axis Cell Number ("Grid cell 1 of 5")</label> </div>
    </fieldset> -->

    <!-- <fieldset class="options-set" id="summarizing" tabindex="0" accesskey="s">
      <legend>Summarizing (s)</legend>
      <div> <input type="checkbox" id="min"> <label for="min">Minimum</label> </div>
      <div> <input type="checkbox" id="max"> <label for="max">Maximum</label> </div>
      <div> <input type="checkbox" id="avg"> <label for="avg">Average</label> </div>
      <div> <input type="checkbox" id="trend"> <label for="trend">Trend</label> </div>
      <div> 
        <input type="checkbox" id="relativeValue" onclick="changeAssociatedInputState(this)"> <label for="relativeValue">Relative Value</label> 
        <input type="number" min='1' max='10' id="relativeValue-input" disabled> <label for="relativeValue-input">Buckets</label>
      </div>
    </fieldset> -->

    <!-- <fieldset class="options-set" id="verbosity" tabindex="0" accesskey="v">
      <legend>Verbosity (least to most) (v)</legend>
      <div> 
        <input type="radio" id="v1" name="verbosity" value="1">
        <label for="v1">1</label><br>
      </div>
      <div>
        <input type="radio" id="v2" name="verbosity" value="2">
        <label for="v2">2</label><br>
      </div>
      <div>
        <input type="radio" id="v3" name="verbosity" value="3" checked>
        <label for="v3">3</label><br>
      </div> 
    </fieldset> -->

    <!-- <p>
      Switch to preset:
      <select id="switch-preset">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
      <button onclick="loadPreset()">Go</button>
    </p>
    <p>
      Save to preset:
      <select id="save-preset">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
      <button onclick="savePreset()">Save</button>
    </p> -->
  </fieldset>

  <img src="img/multiSeriesLineChart.JPG">

  <ul id="description"></ul>

  <p>((aria-live speaking hack))</p>
  <div id="speak" aria-live="assertive"></div>
</div>

<style>
  input[type='number']{
    width: 3em;
  } 
  
  .options-set {
    margin: 1em;
  }

  .no-list-style {
    list-style: none;
  }
</style>

<script>
  const TOKEN_TYPES = [
    'index',
    'type',
    'size',
    'relative',
    'data',
    'aggregate',
    'parent',
    'name',
    'child'
  ];

  const controls = {
    'root': {
        'tokens': ['name']
    },
    'facet': {
      'tokens': ['index', 'type', 'name', 'children'],
      // each list in options must be a subset of tokens; lists are ordered
      'options': {
        'high': ['index', 'type', 'name', 'children'],
        'low': ['type', 'name', 'children'],
      }
    },
    'axis': {
      'tokens': ['name', 'type', 'data', 'size', 'parent'],
      'options': {
        'high': ['name', 'type', 'data', 'size', 'parent'],
        'low': ['name', 'type', 'data'],
      }
    },
    'section': {
      'tokens': ['parent', 'data', 'index', 'size', 'relative'],
      'options': {
        'high': ['parent', 'data', 'index', 'size', 'relative'],
        'low': ['data', 'size'],
      }
    },
    'datapoint': {
      'tokens': ['parent', 'data', 'relative'],
      'options': {
        'high': ['parent', 'data', 'relative'],
        'low': ['data']
      }
    }
  }

  for (let control of Object.keys(controls)) {
    options = controls[control]['options'];
    if (!options) {continue;}

    dropdown = document.createElement('select');
    dropdown.name = control
    dropdown.id = `${control}-verbosity`
    dropdown.setAttribute('onchange', 'updateInfo(this); displayRootDescription(); speakLastFocused();');

    for (option of Object.keys(options)) {
      opt = document.createElement('option');
      opt.innerText = option;
      opt.value = option;
      dropdown.appendChild(opt);
    }

    label = document.createElement('label');
    label.for = control
    label.innerText = `${control} verbosity:`;

    info = document.createElement('p');
    info.innerText = `Description: ${controls[control]['options'][Object.keys(options)[0]].join(', ')}`;

    const menu = document.getElementById('menu');
    const container = document.createElement('div');
    container.appendChild(label);
    container.appendChild(dropdown);
    container.append(info);
    menu.append(container);
  }

  function updateInfo(dropdown) {
    control = dropdown.id.split('-')[0]
    dropdown.nextElementSibling.innerText = `Description: ${controls[control]['options'][dropdown.value].join(', ')}`;
  }

  /***
   *  Event listeners for the menu
   ***/
  let lastActiveDescriptionId = "0"; // 0 is id of root node

  // TODO refactor
  // Reordering event listener
  document.addEventListener('keydown', (e) => {
    if (e.metaKey && e.key === 'ArrowUp') {
      const thisCheckbox = document.activeElement;
      const thisDiv = thisCheckbox.parentNode;
      const previousDiv = thisDiv.previousElementSibling;
      if (previousDiv != null && previousDiv.nodeName !== "LEGEND") {
        // Change menu ordering
        // Note: don't want to call insertBefore(thisDiv, previousDiv)
        // because first parameter to insertBefore loses focus
        thisDiv.insertAdjacentElement('afterend', previousDiv);
        thisCheckbox.focus();
        thisCheckbox.setAttribute('aria-active', true);

        // Change token ordering and refresh description
        thisIdx = TOKEN_TYPES.indexOf(thisCheckbox.id);
        [TOKEN_TYPES[thisIdx], TOKEN_TYPES[thisIdx - 1]] = [TOKEN_TYPES[thisIdx - 1], TOKEN_TYPES[thisIdx]];
        displayRootDescription();   
        speakLastFocused();
      }
    } else if (e.metaKey && e.key === 'ArrowDown') {
      const thisCheckbox = document.activeElement;
      const thisDiv = thisCheckbox.parentNode;
      const nextDiv = thisDiv.nextElementSibling;
      if (nextDiv != null) {
        thisDiv.parentNode.insertBefore(nextDiv, thisDiv);

        thisIdx = TOKEN_TYPES.indexOf(thisCheckbox.id);
        [TOKEN_TYPES[thisIdx], TOKEN_TYPES[thisIdx + 1]] = [TOKEN_TYPES[thisIdx + 1], TOKEN_TYPES[thisIdx]];
        displayRootDescription(); 
        speakLastFocused();  
      }
    }
  })

  function changeAssociatedInputState(input) {
    document.getElementById(`${input.id}-input`).disabled = !input.checked;
  }

  const optionSets = document.getElementsByClassName("options-set");
  for (optionSet of optionSets) {
    for (option of optionSet.children) {
      option.setAttribute('onchange', 'displayRootDescription(); speakLastFocused();');
    }
  }

  function speakLastFocused() {
    srSpeak(document.getElementById(lastActiveDescriptionId).firstChild.innerText);
  }

  /***
   *  Data for the description 
   ***/

  const tree = {
    type: "root",
    tokens: ["A faceted chart with 5 views."],
    children: [
      {
        type: "facet",
        tokens: {
          index: '1 of 5.',
          type: 'Line chart',
          name: 'MSFT',
          children: '"date", "price"'
        },
        children: [
          {
            type: 'axis',
            tokens: {
              type: 'temporal scale',
              size: '5 cells',
              data: '"Jan 1, 2000" to "Jan 1, 2010."',
              parent: '"MSFT"',
              name: 'X-axis "date"', 
            },
            children: []
          },
          {
            type: 'axis',
            tokens: {
              type: 'quantitative scale',
              size: '4 cells',
              data: '"0" to "800"',
              aggregate: 'Average is 25. Minimum is 17.65. Maximum is 39.81.',
              // avg: ['avg 25', 'Average is 25.', 'The average value is 25.'],
              // min: ['min 17.65,', 'Minimum is 17.65.', 'The minimum value is 17.65.'],
              // max: ['max 39.81,', 'Maximum is 39.81.', 'The maximum value is 39.81.'],
              parent: '"MSFT".',
              name: 'Y-axis "price"',
            },
            children: []
          }
        ]
      },
      {
        type: 'facet',
        tokens: {
          index: '2 of 5.',
          type: 'Line chart',
          name: 'AMZN',
          children: '"date", "price"'
        },
        children: [
          {
            type: 'axis',
            tokens: {
              type: 'temporal scale',
              size: '5 cells',
              data: '"Jan 1, 2000" to "Jan 1, 2010."',
              parent: '"AMZN"',
              name: 'X-axis "date"', 
            },
            children: [
              {
                type: 'section',
                tokens: {
                  index: '1 of 6.',
                  size: '0 values.',
                  relative: '',
                  data: 'Dec 31, 1997 to Jan 1, 2000.', 
                  parent: '"x-axis".',
                },
                children: []
              },
              {
                type: 'section',
                tokens: {
                  index: '2 of 6.',
                  size: '24 values.',
                  relative: '',
                  data: 'Jan 1, 2000 to Jan 1, 2002.', 
                  parent: '"x-axis".',
                },
                children: [
                  {
                    type: 'datapoint',
                    tokens: {
                      // index - should be in table by default?
                      relative: '1',
                      data: '64.56, 946702800000',
                      parent: '"AMZN".'
                    },
                    children: []
                  },
                  {
                    type: 'datapoint',
                    tokens: {
                      relative: '1',
                      data: '68.87, 949381200000',
                      parent: '"AMZN".',
                    },
                    children: []
                  },
                ]
              },
            ]
          },
          {
            type: 'axis',
            tokens: {
              type: 'quantitative scale',
              size: '4 cells',
              data: '"0" to "800"',
              aggregate: 'Average is 48. Minimum is 5.97. Maximum is 135.91.',
              // avg: ['avg 48', 'Average is 48.', 'The average value is 48.'],
              // min: ['min 5.97,', 'Minimum is 5.97.', 'The minimum value is 5.97.'],
              // max: ['max 135.91,', 'Maximum is 135.91.', 'The maximum value is 135.91.'],
              parent: '"AMZN".',
              name: 'Y-axis "price"',
            },
            children: []
          }
        ]
      }
    ]
  }

  displayRootDescription();

  function displayRootDescription() {
    const desc = document.getElementById('description');
    desc.innerHTML = '';
    displayRecursiveDescription(tree, desc);
  }

  // `tree` is the tree to generate a description for
  // `dom` is where to add that description
  // `id` is so you can track back from DOM to tree
  // `flags` are any description tokens to turn on
  function displayRecursiveDescription(tree, dom, id = '0', flags=[]) {
    const root = document.createElement('li');
    root.setAttribute('tabindex', 0);
    root.setAttribute('id', id);
    root.classList.add('no-list-style');
    // TODO this accesskeyt thing is tricky because our onchange restriction is actually complex
    root.setAttribute('onfocus', 'lastActiveDescriptionId = this.id; setDescriptionAccesskey(this);');

    text = document.createElement('span');
    text.innerText = getIndivDescription(tree, flags);
    root.appendChild(text);

    if (tree.children.length > 0) {
      const container = document.createElement('ul');
      for (childIdx in tree.children) {
        displayRecursiveDescription(tree.children[childIdx], container, id + '-' + childIdx);
      }
      root.appendChild(container);
    }
    dom.appendChild(root);
  }

  function tokenSort(tokenOrder) {
    // Put all unlisted tokens first, then order remaining tokens by their order in tokenOrder
    return (token1, token2) => {
      includes1 = tokenOrder.includes(token1);
      includes2 = tokenOrder.includes(token2);

      if (!includes1 && !includes2) {
        return 0;
      } else if (!includes1) {
        return -1;
      } else if (!includes2) {
        return 1;
      }
      return tokenOrder.indexOf(token1) - tokenOrder.indexOf(token2);
    }
  }

  function getIndivDescription(node, flags) {
    const verbosity = document.getElementById(`${node.type}-verbosity`);
    if (verbosity) {
      tokenInclude = controls[node.type]['options'][verbosity.value]
    } else {
      tokenInclude = TOKEN_TYPES
    }
    let text = '';

    for (token of (Object.keys(node.tokens)).sort(tokenSort(tokenInclude))) { // TODO
      const checkbox = document.getElementById(token);
      let tokenText = node.tokens[token];

      if (tokenInclude.includes(token) || flags.includes(token)) { 
        text += tokenText + ' ';
      }
    }

    return text;
  }

  

  function getTreeNode(id) {
    const idxs = id.split('-');
    let node = tree;
    for (idx of idxs.slice(1)) {
      node = node.children[idx];
    }
    return node;
  }

  // Set a particular part of the description to have an accesskey
  function setDescriptionAccesskey(elt) {
    document.querySelectorAll('[accesskey="d"]').forEach(el => el.removeAttribute('accesskey'));
    elt.setAttribute('accesskey', 'd');
  }

  /***
   *  Event listeners for the description
   ***/
  document.onkeydown = function (e) {
    keyboardCommands(e);
    keyboardNavigation(e);
  };

  let keylog = '';
  const tokenNames = ['avg', 'min', 'max', 'trend'];
  function keyboardCommands(e) {
    let keypressed = e.key;
    keylog += keypressed;
    for (tokenName of tokenNames) {
      if (keylog.slice(keylog.length - tokenName.length) === tokenName) {
        const node = getTreeNode(document.activeElement.id);
        document.activeElement.firstChild.innerText = getIndivDescription(node, [tokenName]);
        srSpeak(document.activeElement.firstChild.innerText);
      }
    }
  }

  function keyboardNavigation(e) {
    switch (event.key) {
      case 'ArrowRight':
        setFocusToNextItem(document.activeElement);
        break;
      case 'ArrowLeft':
        setFocusToPreviousItem(document.activeElement);
        break;
      case 'ArrowUp':
        setFocusToParentItem(document.activeElement);
        break;
      case 'ArrowDown':
        setFocusToNextLayer(document.activeElement);
        break;
    }
  }

  function changeFocus(old, nw) {
    nw.tabIndex = 0;
    nw.focus();
    nw.setAttribute('aria-selected', 'true');

    old.tabIndex = -1;
    old.setAttribute('aria-selected', 'false');
  }

  function setFocusToNextItem(currentItem) {
    const id = currentItem.id;
    const parentId = id.slice(0, -2);
    const nextChildId = id.slice(0, -1) + (parseInt(id.slice(-1)) + 1).toString() // add 1 to last num
    if (document.getElementById(parentId) && document.getElementById(nextChildId)) {
      changeFocus(currentItem, document.getElementById(nextChildId));
    }
  }

  function setFocusToPreviousItem(currentItem) {
    const id = currentItem.id;
    const parentId = id.slice(0, -2);
    const prevChildId = id.slice(0, -1) + (parseInt(id.slice(-1)) - 1).toString() // add 1 to last num
    if (document.getElementById(parentId) && document.getElementById(prevChildId)) {
      changeFocus(currentItem, document.getElementById(prevChildId));
    }
  }

  function setFocusToNextLayer(currentItem) {
    const child = document.getElementById(currentItem.id + '-0');
    if (child) {
      changeFocus(currentItem, child);
    }
  }

  function setFocusToParentItem(currentItem) {
    const parent = document.getElementById(currentItem.id.slice(0, -2));
    if (parent) {
      changeFocus(currentItem, parent);
    }
  }


  /***
   *  Presets
   ***/
  
  function fieldsToPreset() {
    const result = {}
    for (optionsSet of document.getElementsByClassName('options-set')) {
      const options = {};
      for (option of optionsSet.children) {
        const value = option.firstElementChild;
        if (value) { // Skips the text/legend nodes
          options[value.id] = value.checked;
        }
      }
      result[optionsSet.id] = options;
    }
    return result;
  }

  const presets = {1: fieldsToPreset(), 2: fieldsToPreset(), 3: fieldsToPreset()}

  function presetToFields(num) {
    const preset = presets[num];
    for (optionsSet of document.getElementsByClassName('options-set')) {
      for (option of optionsSet.children) {
        const value = option.firstElementChild;
        if (value) {
          value.checked = preset[optionsSet.id][value.id];
        }
      }
    }
  }

  function loadPreset() {
    presetToFields(document.getElementById('switch-preset').value);
  }

  function savePreset() {
    presets[document.getElementById('save-preset').value] = fieldsToPreset();
  }

  /***
   *  Hack to make screenreader re-read text when it is changed
   ***/
  function srSpeak(text) {
    console.log(text);
    window.setTimeout(function () {
      const el = document.getElementById('speak');
      el.innerHTML = text;
    }, 100);
  }
</script>